<!DOCTYPE html>
<html>
<head>
<style>
  body {
    margin: 0;
    padding: 0;
    font-size: 16px;
    background-color: #333;
  }
  #vwrap {
    width: 855px;
    height: 480px;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
  }
  #vwrap * {
    position: absolute;
  }
  #thev {
    width: 855px;
    height: 480px;
  }
  #info {
    height: 90px;
    bottom: 15px;
    left: 10px;
    right: 10px;
    background-color: rgba(0,0,0,0.7);
    color: white;
    font-size: 0.8em;
  }
  #timeline {
    height: 11px;
    top: 10px;
    left: 5px;
    right: 5px;
    background-color: purple;
  }
  #video_title, #time_info {
    top: 36px;
  }
  #video_title {
    width: 200px;
    left: 10px;
    font-size: 1.2em;
    font-weight: bold;
  }
  #time_info {
    width: 150px;
    right: 10px;
  }
  #time_info div {
    position: relative;
    display: inline;
    width: 30px;
    margin: 0;
    padding: 0;
  }
  #time_info div:first-child::after {
    content: " / ";
  }
</style>
</head>

<body>

<div id="vwrap">
<video id="thev" data-title="Just a Test Video">
  <source src="thevideo-edited.mp4" type="video/mp4">
</video>
</div>

<script>
var vwrap = document.querySelector("#vwrap");
vwrap.tabIndex = 1;
vwrap.focus(); // this will allow it to receive key events
var v = document.querySelector("#thev");


// CREATE VIDEO INFO BOX AND TIMELINE
var info = document.createElement("div"); // outer container
info.id = "info";
var tl = document.createElement("div");   // outer timeline
tl.id = "timeline";
var ph = document.createElement("div");   // playhead
ph.id = "playhead";
tl.appendChild(ph);
info.appendChild(tl);
var vt = document.createElement("div");   // video title
vt.id = "video_title";
vt.innerText = v.getAttribute("data-title");
info.appendChild(vt);
var ti = document.createElement("div");   // time info
ti.id = "time_info";
var cur = document.createElement("div");
var dur = document.createElement("div");
ti.appendChild(cur);
ti.appendChild(dur);
info.appendChild(ti);
vwrap.appendChild(info);


// RETRIEVE AND DISPLAY TIMES

function zeroFill(num, fillTo) {
  num = String(num);
  while(fillTo - num.length) {
    num = "0" + num;
  }
  return num;
}

function formatTime(secs) {
  
  var h = Math.floor(secs / 3600);
  var m = Math.floor((secs / 60) - ((h * 3600) / 60));
  var s = secs - (h * 3600) - (m * 60);
  
  return zeroFill(h, 2) + ":" + zeroFill(m, 2) + ":" + zeroFill(s, 2);
}

v.addEventListener("timeupdate", function (e) {
  cur.innerText = formatTime(Math.floor(v.currentTime));
});

v.addEventListener("durationchange", function (e) {
  dur.innerText = formatTime(Math.floor(v.duration));
});


// CONTROLS

// navigation:
// l/r arrow keys to scrub video
// alt + l/r arrow keys will scrub according to the last-set seek interval
// pageup/pagedown will scrub chapter markers
// home/end will go to beginning and end
// spacebar will play/pause
// press and hold l/r key (after tempo timeout elapses) to advance a second at every interval (10x faster)
// mousewheel to scrub chapter markers; left or middle mouse button to apply, right button or esc key to cancel


var int = 500; // amount in milliseconds to run the interval
var skipBy = 10; // seconds to skip forward or backward
var velBy = 5; // x5 with every velocity increment
var autoOnDelay = 1; // in seconds
var autoOffDelay = 2.5;
var seek = {
  init: 0, // timestamp of when action was initialized
  paused: v.paused,
  vel: 0, // basically 'play'
  auto: false
};

var mainInt = setInterval(function () {
  
  if (seek.auto) {
    v.currentTime = Math.max(0, Math.min(v.duration, v.currentTime + seek.vel));
    vel.value = seek.vel;
  }
}, int);

vwrap.addEventListener("keydown", function (e) {
  
  e.preventDefault(); // prevents arrow keys from scrolling page and whatever else
  // The fact that this handler is attached to vwrap and not window means that it will not preventDefault when vwrap loses focus.
  
  if (/left|right/i.test(e.key)) {
    
    var dir = /left/i.test(e.key) ? -1 : 1;
    
    // initialize new seek
    if (!seek.vel) {
      seek.init = Date.now();
      seek.paused = v.paused;
      seek.vel = dir;
      seek.auto = false;
    }
    
    // no change
    else if (seek.auto && seek.init) return;
    
    // turn on auto seek
    else if (!seek.auto && seek.init) {
      // time in seconds between now and init time
      seek.auto = (Date.now() - seek.init) >= (autoOnDelay * 1000);
      if (seek.auto && !v.paused) v.pause();
    }
    
    // shift seek velocity
    else if (seek.auto && !seek.init) {
      seek.init = Date.now(); // begin new timer
      // increment/decrement velocity
      // (dir * seek.vel) < 0 because negative * positive will always be negative
      // and vice versa, so if the product is negative, the vector has changed
      seek.vel *= (((dir * seek.vel) > 0) ? velBy : (1 / velBy));
      // (1 / velBy) inverts the number and shifts the velocity
    }
    
  }
});

vwrap.addEventListener("keyup", function (e) {

  // play/pause on keyup so it doesn't keep repeating, as it would on a keydown
  if (/\s/.test(e.key)) { // play/pause
    if (seek.vel) { // clear seek if one is in progress
      seek.init = 0;
      seek.vel = 0;
      seek.auto = false;
    }
    v[v.paused ? "play" : "pause"]();
  }
  else if (/home/i.test(e.key)) v.currentTime = 0;
  else if (/end/i.test(e.key)) v.currentTime = v.duration;
  // chapter markers
  else if (/pageup|arrowup/i.test(e.key));
  else if (/pagedown|arrowdown/i.test(e.key));
  else if (/left|right/i.test(e.key)) {
    
    var dir = /left/i.test(e.key) ? -1 : 1;
    
    if (!seek.auto) {
      seek.init = 0;
      v.currentTime += dir * skipBy;
    }
    else if (seek.auto && seek.init &&
          ((Date.now() - seek.init) >= (autoOffDelay * 1000))) {
      // reset all
      seek.init = 0;
      seek.vel = 0;
      seek.auto = false;
      seek.paused || v.play();
    }
  }
});

vwrap.addEventListener("mouseup", function (e) {
  
  console.log(e.target);
});
v.addEventListener("mouseup", function (e) {
  
  console.log(e.target);
});


</script>

</body>
</html>
