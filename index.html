<!DOCTYPE html>
<html>
<head>
<style>

  body {
    margin: 0;
    padding: 0;
    font-size: 16px;
    background-color: #333;
    font-family: sans-serif;
  }
  #vwrap {
    width: 855px;
    height: 480px;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
    overflow: hidden;
  }
  #vwrap * {
    position: absolute;
  }
  #thev {
    width: 855px;
    height: 480px;
  }
  #info {
    height: 50px; /* keyframe should match */
    bottom: -50px; /* this will change to 0 when turned on */
    left: 0;
    right: 0;
    background-color: rgba(0,0,0,0.65);
    color: white;
    font-size: 0.8em;
  }
  @keyframes info_on {
    from {bottom: -50px}
    to   {bottom: 0}
  }
  @keyframes info_off {
    from {bottom: 0}
    to   {bottom: -50px}
  }
  #info.on {
    animation-name: info_on;
    animation-duration: 0.3s;
    animation-timing-function: ease-out;
    animation-fill-mode: both;
  }
  #info.off {
    animation-name: info_off;
    animation-duration: 0.3s;
    animation-timing-function: ease-in;
    animation-fill-mode: both;
    animation-delay: 1s;
  }
  #timeline {
    height: 9px;
    top: 7px;
    left: 5px;
    right: 5px;
    background-color: #800080;
    overflow: visible;
  }
  #buffered_ranges {
    width: 100%;
    height: 100%;
  }
  .buffered {
    height: 100%;
    background-color: #be60bd;
  }
  #playhead {
    width: 7px;
    height: 11px;
    top: -1px;
    background-color: #cc66cc;
  }
  #video_title, #time_info {
    top: 25px;
  }
  #video_title {
    width: 200px;
    left: 10px;
    font-size: 1.2em;
    font-weight: bold;
  }
  #time_info {
    right: 10px;
    white-space: nowrap;
  }
  #time_info div {
    position: relative;
    display: inline;
    margin: 0;
    padding: 0;
  }
  #time_info div:first-child::after {
    content: " / ";
  }
</style>
</head>

<body>

<div id="vwrap">
<video id="thev" data-title="Just a Test Video">
  <source src="thevideo-edited.mp4" type="video/mp4">
</video>
</div>

<script>

var vwrap = document.querySelector("#vwrap");
vwrap.tabIndex = 1;
vwrap.focus(); // this will allow it to receive key events
var v = document.querySelector("#thev");

// CREATE ELEMENTS
var info = document.createElement("div"); // outer container
info.id = "info";
var tl = document.createElement("div");   // outer timeline
tl.id = "timeline";
var buf = document.createElement("div");  // container for buffered ranges in timeline
buf.id = "buffered_ranges";
tl.appendChild(buf);
var ph = document.createElement("div");   // playhead
ph.id = "playhead";
tl.appendChild(ph);
info.appendChild(tl);
var vt = document.createElement("div");   // video title
vt.id = "video_title";
vt.innerText = v.getAttribute("data-title");
info.appendChild(vt);
var ti = document.createElement("div");   // time info
ti.id = "time_info";
var cur = document.createElement("div");
var dur = document.createElement("div");
ti.appendChild(cur);
ti.appendChild(dur);
info.appendChild(ti);
vwrap.appendChild(info);

// initialize some values
tl.w = parseInt(window.getComputedStyle(tl).width);
ph.w = parseInt(window.getComputedStyle(ph).width);


// RETRIEVE AND DISPLAY TIMES

// some utility functions
function zeroFill(num, fillTo) {
  num = String(num);
  while(fillTo - num.length) {
    num = "0" + num;
  }
  return num;
}

function formatTime(secs) {

  var h = Math.floor(secs / 3600);
  var m = Math.floor((secs / 60) - ((h * 3600) / 60));
  var s = secs - (h * 3600) - (m * 60);

  return zeroFill(h, 2) + ":" + zeroFill(m, 2) + ":" + zeroFill(s, 2);
}


//  initialize some values
cur.innerText = formatTime(0);
var int = 500;
var skipBy = 10; // seconds to skip forward or backward
var velBy = 5; // x5 with every velocity increment
var autoOnDelay = 1; // in seconds
var autoOffDelay = 2.5;
var seek = {
  init: 0, // timestamp of when action was initialized
  paused: v.paused,
  vel: 0, // basically 'play'
  auto: false
};


var mainInt = setInterval(function () {

  // update timeline

  // buffered ranges
  for (var i = 0; i < v.buffered.length; i++) {
    // go through any possible ranges that already exist
    // if the current one shares a start time with an existing one, do not create new
    var rgs = buf.querySelectorAll(".buffered");
    var exists = function () {
      for (var j in rgs) {
        if (rgs[j].s == v.buffered.start(i)) return rgs[j];
      }
      return null;
    }();
    var r = function () {
      if (exists) return exists;
      var d = document.createElement("div");
      d.className = "buffered";
      buf.appendChild(d);
      return d;
    }();
    r.s = v.buffered.start(i);
    r.e = v.buffered.end(i);
    var s = r.s / v.duration;
    var e = r.e / v.duration;
    r.style.left = s * tl.w + "px";
    r.style.width = (e - s) * tl.w + "px";
  }

  // play progress
  if (v.currentTime != v.lastTime) { // careful references v.lastTime before it's been declared. May cause problems in strict mode
    cur.innerText = formatTime(Math.floor(v.currentTime));
    ph.style.left = (tl.w - ph.w) * (v.currentTime / v.duration) + "px";
    v.lastTime = v.currentTime;
  }

  // handle seek
  if (seek.auto) {
    v.currentTime = Math.max(0, Math.min(v.duration, v.currentTime + seek.vel));
  }
}, int);



v.addEventListener("timeupdate", function (e) {
  /*
    Do not use timeupdate event since it's dispatched too fast and with inconsistent timing,
    which is dependent on system load and other factors.
    Instead update timeline and related elements through much slower interval above.
  */
});

v.addEventListener("durationchange", function (e) {
  dur.innerText = formatTime(Math.floor(v.duration));
});


// CONTROLS

// navigation:
// l/r arrow keys to scrub video
// alt + l/r arrow keys will scrub according to the last-set seek interval
// pageup/pagedown will scrub chapter markers
// home/end will go to beginning and end
// spacebar will play/pause
// press and hold l/r key (after tempo timeout elapses) to advance a second at every interval (10x faster)
// mousewheel to scrub chapter markers; left or middle mouse button to apply, right button or esc key to cancel




vwrap.addEventListener("keydown", function (e) {

  e.preventDefault(); // prevents arrow keys from scrolling page and whatever else
  // The fact that this handler is attached to vwrap and not window means that it will not preventDefault when vwrap loses focus.

  if (/left|right/i.test(e.key)) {

    var dir = /left/i.test(e.key) ? -1 : 1;

    // initialize new seek
    if (!seek.vel) {
      seek.init = Date.now();
      seek.paused = v.paused;
      seek.vel = dir;
      seek.auto = false;
    }

    // no change
    else if (seek.auto && seek.init) return;

    // turn on auto seek
    else if (!seek.auto && seek.init) {
      // time in seconds between now and init time
      seek.auto = (Date.now() - seek.init) >= (autoOnDelay * 1000);
      if (seek.auto && !v.paused) v.pause();
    }

    // shift seek velocity
    else if (seek.auto && !seek.init) {
      console.log("hello");
      seek.init = Date.now(); // begin new timer
      // increment/decrement velocity
      // (dir * seek.vel) < 0 because negative * positive will always be negative
      // and vice versa, so if the product is negative, the vector has changed
      seek.vel *= (((dir * seek.vel) > 0) ? velBy : (1 / velBy));
      // (1 / velBy) inverts the number and shifts the velocity
    }

    else {
      console.log("nope");
    }

  }
});

vwrap.addEventListener("keyup", function (e) {

  // play/pause on keyup so it doesn't keep repeating, as it would on a keydown
  if (/\s/.test(e.key)) { // play/pause
    if (seek.vel) { // clear seek if one is in progress
      seek.init = 0;
      seek.vel = 0;
      seek.auto = false;
    }
    v[v.paused ? "play" : "pause"]();
  }
  else if (/home/i.test(e.key)) v.currentTime = 0;
  else if (/end/i.test(e.key)) v.currentTime = v.duration;
  // chapter markers
  else if (/pageup|arrowup/i.test(e.key));
  else if (/pagedown|arrowdown/i.test(e.key));
  else if (/left|right/i.test(e.key)) {

    var dir = /left/i.test(e.key) ? -1 : 1;

    if (!seek.auto) {
      seek.init = 0;
      v.currentTime += dir * skipBy;
    }
    else if (seek.auto && seek.init &&
          ((Date.now() - seek.init) >= (autoOffDelay * 1000))) {
      // reset all
      seek.init = 0;
      seek.vel = 0;
      seek.auto = false;
      seek.paused || v.play();
    }
  }
});

vwrap.addEventListener("mouseup", function (e) {

  //console.log(e.target);
});
v.addEventListener("mouseup", function (e) {

  //console.log(e.target);
});


// FOCUS SETTING
vwrap.addEventListener("mouseenter", function (e) {
  info.className = "on";
});
vwrap.addEventListener("mouseleave", function (e) {
  info.className = "off";
});

</script>

</body>
</html>
