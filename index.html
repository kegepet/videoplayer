<!DOCTYPE html>
<html>
<head>
<style>
  body {
    margin: 0;
    padding: 0;
    font-size: 16px;
  }
  #vwrap, #vcontrols {
    display: inline-block;
    border: solid 1px red;
    vertical-align: top;
  }
  #vwrap {
    margin: 0;
    padding: 0;
  }
  #thev {
   /* width: 720px;
    height: 480px;*/
  }
  #vcontrols {
    width: 200px;
    margin: 0;
    padding: 0;
  }
  #vcontrols * {
    display: block;
  }
</style>
</head>

<body>

<div id="vwrap">
<video id="thev">
  <source src="thevideo-edited.mp4" type="video/mp4">
</video>
</div>
<div id="vcontrols">
  <label for="dur">Duration</label>
  <input type="text" id="dur" readonly>
  <label for="cur">Current Time</label>
  <input type="text" id="cur" readonly>
  <label for="vel">Velocity</label>
  <input type="text" id="vel" readonly>
</div>

<script>
var vwrap = document.querySelector("#vwrap");
vwrap.tabIndex = 1;
vwrap.focus(); // this will allow it to receive key events
var v = document.querySelector("#thev");
var c = document.querySelector("#vcontrols");
var dur = c.querySelector("#dur");
var cur = c.querySelector("#cur");
var vel = c.querySelector("#vel");


// RETRIEVE AND DISPLAY TIMES

function zeroFill(num, fillTo) {
  num = String(num);
  while(fillTo - num.length) {
    num = "0" + num;
  }
  return num;
}

function formatTime(secs) {
  
  var h = Math.floor(secs / 3600);
  var m = Math.floor((secs / 60) - ((h * 3600) / 60));
  var s = secs - (h * 3600) - (m * 60);
  
  return zeroFill(h, 2) + ":" + zeroFill(m, 2) + ":" + zeroFill(s, 2);
}

v.addEventListener("timeupdate", function (e) {
  cur.value = formatTime(Math.floor(v.currentTime));
});

v.addEventListener("durationchange", function (e) {
  dur.value = formatTime(Math.floor(v.duration));
});


// CONTROLS

// navigation:
// l/r arrow keys to scrub video
// alt + l/r arrow keys will scrub according to the last-set seek interval
// pageup/pagedown will scrub chapter markers
// home/end will go to beginning and end
// spacebar will play/pause
// press and hold l/r key (after tempo timeout elapses) to advance a second at every interval (10x faster)
// mousewheel to scrub chapter markers; left or middle mouse button to apply, right button or esc key to cancel


var int = 500; // amount in milliseconds to run the interval
var skipBy = 10; // seconds to skip forward or backward
var velBy = 5; // x5 with every velocity increment
var autoOnDelay = 1; // in seconds
var autoOffDelay = 2.5;
var seek = {
  init: 0, // timestamp of when action was initialized
  paused: v.paused,
  vel: 0, // basically 'play'
  auto: false
};

var mainInt = setInterval(function () {
  
  if (seek.auto) {
    v.currentTime = Math.max(0, Math.min(v.duration, v.currentTime + seek.vel));
    vel.value = seek.vel;
  }
}, int);

vwrap.addEventListener("keydown", function (e) {
  
  e.preventDefault(); // prevents arrow keys from scrolling page and whatever else
  // The fact that this handler is attached to vwrap and not window means that it will not preventDefault when vwrap loses focus.
  
  if (/left|right/i.test(e.key)) {
    
    var dir = /left/i.test(e.key) ? -1 : 1;
    
    // initialize new seek
    if (!seek.vel) {
      seek.init = Date.now();
      seek.paused = v.paused;
      seek.vel = dir;
      seek.auto = false;
    }
    
    // no change
    else if (seek.auto && seek.init) return;
    
    // turn on auto seek
    else if (!seek.auto && seek.init) {
      // time in seconds between now and init time
      seek.auto = (Date.now() - seek.init) >= (autoOnDelay * 1000);
      if (seek.auto && !v.paused) v.pause();
    }
    
    // shift seek velocity
    else if (seek.auto && !seek.init) {
      seek.init = Date.now(); // begin new timer
      // increment/decrement velocity
      // (dir * seek.vel) < 0 because negative * positive will always be negative
      // and vice versa, so if the product is negative, the vector has changed
      seek.vel *= (((dir * seek.vel) > 0) ? velBy : (1 / velBy));
      // (1 / velBy) inverts the number and shifts the velocity
    }
    
  }
});

vwrap.addEventListener("keyup", function (e) {

  // play/pause on keyup so it doesn't keep repeating, as it would on a keydown
  if (/\s/.test(e.key)) { // play/pause
    if (seek.vel) { // clear seek if one is in progress
      seek.init = 0;
      seek.vel = 0;
      seek.auto = false;
    }
    v[v.paused ? "play" : "pause"]();
  }
  else if (/home/i.test(e.key)) v.currentTime = 0;
  else if (/end/i.test(e.key)) v.currentTime = v.duration;
  // chapter markers
  else if (/pageup|arrowup/i.test(e.key));
  else if (/pagedown|arrowdown/i.test(e.key));
  else if (/left|right/i.test(e.key)) {
    
    var dir = /left/i.test(e.key) ? -1 : 1;
    
    if (!seek.auto) {
      seek.init = 0;
      v.currentTime += dir * skipBy;
    }
    else if (seek.auto && seek.init &&
          ((Date.now() - seek.init) >= (autoOffDelay * 1000))) {
      // reset all
      seek.init = 0;
      seek.vel = 0;
      seek.auto = false;
      seek.paused || v.play();
    }
  }
});

vwrap.addEventListener("mouseup", function (e) {
  
  console.log(e.target);
});
v.addEventListener("mouseup", function (e) {
  
  console.log(e.target);
});


</script>

</body>
</html>
